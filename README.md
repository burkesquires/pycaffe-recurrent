# pycaffe-recurrent
IPython notebook for training multilayer LSTM and RNN networks with pycaffe


Example of generated code after training on the Linux kernel for a few hours (average test loss ~1):
 ``` cpp
static int __init bit_next_worker_lock_update(void *arg)
{
	if (cpumask_set_cpu(cpu) + 1) {
		struct dentry *dst_cset = cgroup_mutex;

		current->trace_buffers[cpu] = AUDIT_TIMER_SPINLOCK_SIZE << PAGE_SIZE)
		return;

	/* initialize we be possible */
	for (kdb_size != STA_SYS_READ)
		return;

	for_each_update_read(se);

		rcu_read_lock();
	}

	return 0;
}

static inline void cmd_state_nr_callbacks, int reset_update_print_scan_mintatup(struct seq_file *m, void *v)
{
	struct trace_array *tr;
	struct irq_data *start;
	struct rcu_node *rnp = trace_rcu_cleanup(size_t, kp);
}

static void ftrace_print_ptr(const struct ftrace_hash *timer, struct compat_trigger *data)
{
	if (should_hash->handler_len) {
		struct trace_buffer *buffer;
		if (!strtn | (trace_notifier_buffer_lock))
			create_lock_reserve(&rt_rq->rt_rq);
		continue;
		break;

	case ENTRIESC_RESTART
		kdb_printf("\n");
		return 0;
	}

	return true;
}

/*
 * Precent.
 *
 * We can get is to the ring buffer.
 */
static inline void tick_deferred(void *iter)
{
	if (lock_count_start, commmtable_total->signal_cpus,
			           new_aux.dinable_regs)
		if (!sechdrs[cpu].expires & ALLOUS_PER_BOOTH, 0);
		return ret;
	}

	if (iter->sequence;
	} while (trace_option_read_cpu(tsk));

	return ret;
}

```
